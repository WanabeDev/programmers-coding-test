// 🚫Wrong Answer 01(처리 시간이 오래걸려 테스트를 통과하지 못한 풀이)
function solution(num_list) {
  let count = 0;
  while (!num_list.every((e) => e === 1)) {
    num_list.forEach((e, i) => {
      if (e % 2 === 0) {
        num_list[i] = e / 2;
        count++;
      } else {
        num_list[i] = (e - 1) / 2;
        count++;
      }
    });
  }
  return count;
}

// Answer 01(1일경우를 제외시켜 불필요한 연산을 수행하지 않게 함)
function solution(num_list) {
  var count = 0;
  while (!num_list.every((e) => e === 1)) {
    num_list.forEach((e, i) => {
      if (num_list[i] !== 1 && e % 2 === 0) {
        num_list[i] = e / 2;
        count++;
      } else if (num_list[i] !== 1 && e % 2 !== 0) {
        num_list[i] = (e - 1) / 2;
        count++;
      }
    });
  }
  return count;
}

// Another approach 01(값을 2진수로 변환하여 최하위 비트를 제거하는것으로 짝수, 홀수를 처리함)
function solution(num_list) {
  return num_list.map((v) => v.toString(2).length - 1).reduce((a, c) => a + c);
}
/*
초기 배열: [12, 4, 15, 1, 14], count: 0
12을 이진수로 변환하면 1100이며, 비트 수는 4입니다.
4를 이진수로 변환하면 100이며, 비트 수는 3입니다.
15를 이진수로 변환하면 1111이며, 비트 수는 4입니다.
1을 이진수로 변환하면 1이며, 비트 수는 1입니다.
14를 이진수로 변환하면 1110이며, 비트 수는 4입니다.

연산 과정 및 연산 회수:
2-1) 12을 처리
12은 이진수로 1100입니다.
비트 수가 4이므로 3번의 연산이 필요합니다.
첫 번째 비트 1을 제외한 3개의 비트에 대해 연산을 수행합니다.
연산 후 배열: [6, 2, 15, 1, 7], count: 3

2-2) 4를 처리
4는 이진수로 100입니다.
비트 수가 3이므로 2번의 연산이 필요합니다.
모든 비트에 대해 연산을 수행합니다.
연산 후 배열: [3, 1, 15, 1, 7], count: 5

2-3) 15를 처리
15는 이진수로 1111입니다.
비트 수가 4이므로 3번의 연산이 필요합니다.
첫 번째 비트 1을 제외한 3개의 비트에 대해 연산을 수행합니다.
연산 후 배열: [3, 1, 7, 0, 7], count: 8

2-4) 1을 처리
1은 이진수로 1입니다.
비트 수가 1이므로 연산이 필요하지 않습니다.
연산 후 배열: [3, 1, 7, 0, 7], count: 8

2-5) 14를 처리
14는 이진수로 1110입니다.
비트 수가 4이므로 3번의 연산이 필요합니다.
첫 번째 비트 1을 제외한 3개의 비트에 대해 연산을 수행합니다.
연산 후 배열: [3, 1, 7, 0, 3], count: 11
따라서, 각 요소가 1이 되기까지 필요한 연산 횟수는 각각 3, 2, 3, 0, 3이며, 총 연산 횟수는 11입니다.
*/
